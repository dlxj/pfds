# 演習問題 6.2

## (a)

> 不変条件を $|f|\ge |r|$ から $2|f|\ge |r|$ に変えても $O(1)$ の償却上限が成立することを示す。
> $$
> D(i)\le \min(2i, 2|f|-|r|)
> $$
>

### アウトライン

- 場合分け
  - snoc, tail, 回転の有無
- 回転しない場合
  - 負債不変条件を脅かす要素を挙げる
  - 必要な負債の返済量を示す
- 回転する場合
  - 回転自体で発生する負債だけに着目する
  - 回転操作を分割し、逐次関数、一枚岩関数毎にノードへの負債を挙げる
  - 各ノードで負債不変条件が成立することを示す

### 証明

`snoc` と `tail` はそれぞれ 1, 3 の負債を返済することで負債不変条件 $D(i)\ge \min(3i, 2|f|-|r|)$ を維持する。

- 回転を起こさない `snoc`

  - 末尾側ストリームに要素を追加、 $|r|$ が 1 増える
    - $2|f|-|r|$ が 1 減る
  - 不変条件を守るには
    - キューの先頭の負債を返済し、全ての後続の累積負債を 1 ずつ減らす

- 回転を起こさない `tail`

  - 先頭側ストリームから要素を削除、$|f|$ が 1 減る
    - $2|f|-|r|$ が 2 減る
    - $3i$ が 3 減る
  - 不変条件を守るには
    - キューの先頭 3 つの負債を返済し、全ての後続の累積負債を 3 ずつ減らす

- 回転を引き起こす `snoc` と `tail` : 

  - 回転のときに $|f|=m$ かつ $|r|=2m+1$ であれば、
    - `++` のために $m$ の負債：先頭 $m$ ノードに 1 つずつ負わせる
    - `reverse` のために $2m+1$ の負債：$m+1$ 番目のノードに $2m+1$ の負債を負わせる
  - 負債は次を満たすように分散される

  $$
  d(i) =
  \begin{cases}
  1 & i<m\ のとき \\
  2m+1 & i=m\ のとき \\
  0 & i>m\ のとき
  \end{cases}
  \qquad
  かつ
  \qquad
  D(i) = \begin{cases}
  i+1 & i<m\ のとき \\
  3m+1 & i\ge m\ のとき
  \end{cases}
  $$

  - あとは、ノード 0 の負債を返済すれば不変条件を守ることができる 

## (b)

> 100 回の `snoc` の後に 100 回の `tail` を行う走査の列において、2つの実装の相対的な性能を比較する。

- $|f|\ge |r|$ の場合
  - `snoc` では、1,3,7,15,31,63 （$2^k-1$ ）回目で回転し、100回目終了時は $f/r = 63/37$
  - `tail` では、27 回目で回転するのみ
  - 以上 7 回
- $2|f|\ge |r|$ の場合
  - `snoc` では、1,4,13,40（$\frac{3^k-1}{2}$ ）回目で回転し、100回目終了時は $f/r = 63/37$
  - `tail` では、11 回目で回転するのみ
  - 以上 5 回
- よって、この場合後者が早くなる。



## ？

p69 ノード0の負債を返済すればいいってのはわかるけど、どうやって返済するの？

- snoc でも tail でも、最初の1回だけ1つ多く返済してもオーダはかわらないってこと？
- はい。