# 演習問題 6.6

次の誤った「最適化」 が $O(1)$ を壊してしまう理由を示す。

## (a)

> 変更点: `check` が回転の際に `w` ← `force f` しているのを `w` が空になるまで `force f` させないよう変更

`w` が空になったとき、ここで初めて `checkw` が `force f` することになる。

これは $|f|$ の非共有コストの発生を意味し、`w` が空になる直前のデータを永続的に使用すると $O(1)$ でなくなってしまう。

## (b)

> 変更点: `tail` で `f` を `$tl (force f)` に置き換えず、単に `lenf` を1減らすだけに変更

`w` が空になったとき、`f` と同期させるために `drop n (force f)` する必要があり、これは $|f|$ の非共有コストを発生させる。

- $n$ を $O(1)$ で算出するにはデータ構造上に記録しておく必要がありそう